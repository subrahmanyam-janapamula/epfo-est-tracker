import React, { useState, useMemo, useEffect } from 'react';
import { AppData, Transaction } from './types';
import { DEFAULT_PROFILE } from './constants';
import { calculateTimeline } from './services/calculationService';
import { loadData, saveData } from './services/storageService';
import Sidebar from './components/Sidebar';
import Dashboard from './components/Dashboard';
import YearList from './components/YearList';
import TransactionManager from './components/TransactionManager';
import Configuration from './components/Configuration';
import { Menu } from 'lucide-react';

const App: React.FC = () => {
  const [currentView, setCurrentView] = useState('dashboard');
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  
  // Initialize with a valid AppData structure to avoid runtime errors before loadData() completes
  const [data, setData] = useState<AppData>({
    profile: DEFAULT_PROFILE,
    transactions: [],
    interestRates: {}
  });
  const [isLoaded, setIsLoaded] = useState(false);

  // Load data on mount
  useEffect(() => {
    const loaded = loadData();
    // Merge loaded data with defaults to ensure structure validity
    setData({
      profile: { ...DEFAULT_PROFILE, ...loaded.profile },
      transactions: Array.isArray(loaded.transactions) ? loaded.transactions : [],
      interestRates: loaded.interestRates || {}
    });
    setIsLoaded(true);
  }, []);

  // Save data on change
  useEffect(() => {
    if (isLoaded) {
      saveData(data);
    }
  }, [data, isLoaded]);

  const handleUpdateProfile = (field: string, value: any) => {
    setData(prev => ({
      ...prev,
      profile: { ...prev.profile, [field]: value }
    }));
  };

  const handleBatchGenerate = (year: number, amount: number, rate: number) => {
    // Generate 12 monthly contributions for the FY
    // FY starts April 1st of `year`
    const newTransactions: Transaction[] = [];
    const fyStart = new Date(year, 3, 1); // April 1st
    
    // Check bounds
    const joinDate = new Date(data.profile.joiningDate);
    const endDate = data.profile.endDate ? new Date(data.profile.endDate) : null;

    for (let i = 0; i < 12; i++) {
      const actualYear = year + (i < 9 ? 0 : 1);
      const actualMonth = (i + 3) % 12; // 0=Jan, 3=Apr
      
      const monthStartDate = new Date(actualYear, actualMonth, 1);
      
      // Contribution Date: Last day of the wage month
      const contribDate = new Date(actualYear, actualMonth + 1, 0);

      // Transaction Date: 15th of the NEXT month (approximate deposit date)
      const txnDate = new Date(actualYear, actualMonth + 1, 15);

      // Skip if before joining
      if (contribDate < joinDate) continue;
      // Skip if strictly after endDate (if exists)
      if (endDate && contribDate > endDate) continue;
      
      newTransactions.push({
        id: `gen-${contribDate.getTime()}-${Math.random()}`,
        contributionDate: contribDate.toISOString().split('T')[0],
        transactionDate: txnDate.toISOString().split('T')[0],
        amount: amount,
        type: 'contribution',
        description: 'Monthly Contribution',
        isAutoGenerated: true
      });
    }

    const fyStartStr = fyStart.toISOString().split('T')[0];
    const fyEndStr = new Date(year + 1, 2, 31).toISOString().split('T')[0];

    setData(prev => {
       const filtered = prev.transactions.filter(t => {
          // If it's a contribution within this FY, remove it ONLY if it was auto-generated or we assume standard overwrite
          // Filter based on contribution date matching the FY
          const tDate = t.contributionDate;
          const inRange = tDate >= fyStartStr && tDate <= fyEndStr;
          if (inRange && t.type === 'contribution' && (t.isAutoGenerated || t.description === 'Monthly Contribution')) {
             return false;
          }
          return true;
       });
       
       return {
         ...prev,
         transactions: [...filtered, ...newTransactions],
         interestRates: { ...prev.interestRates, [year]: rate }
       };
    });
  };

  const handleAddTransaction = (t: Transaction) => {
    setData(prev => ({
      ...prev,
      transactions: [...prev.transactions, t]
    }));
  };

  const handleUpdateTransaction = (t: Transaction) => {
    setData(prev => ({
        ...prev,
        transactions: prev.transactions.map(old => old.id === t.id ? t : old)
    }));
  };

  const handleDeleteTransaction = (id: string) => {
    setData(prev => ({
      ...prev,
      transactions: prev.transactions.filter(t => t.id !== id)
    }));
  };

  const handleDeleteYear = (year: number) => {
    if (!window.confirm(`Are you sure you want to delete all transactions and configuration for FY ${year}-${(year+1)%100}? This action cannot be undone.`)) {
      return;
    }

    const fyStart = `${year}-04-01`;
    const fyEnd = `${year + 1}-03-31`;

    setData(prev => {
      // Filter out transactions belonging to this FY based on contributionDate
      const newTransactions = prev.transactions.filter(t => {
         const d = t.contributionDate;
         return d < fyStart || d > fyEnd;
      });
      
      // Remove interest rate for that year
      const newRates = { ...prev.interestRates };
      delete newRates[year];

      // Logic to reduce targetDate if we are deleting the last generated year
      // This prevents the calculation engine from regenerating the empty year immediately
      let newProfile = { ...prev.profile };
      const currentTargetDate = new Date(prev.profile.targetDate);
      
      // If the deleted year's end date is greater than or equal to current target date, 
      // we should roll back the target date to the end of the previous FY.
      const fyEndDateObj = new Date(year + 1, 2, 31); // March 31 of next year
      
      if (fyEndDateObj >= currentTargetDate || fyEndDateObj.getFullYear() === currentTargetDate.getFullYear()) {
         // Set target date to March 31 of the DELETED year (which is effectively end of PREV FY)
         // e.g., deleting FY2026-27 (ends Mar 31, 2027). We want target to be Mar 31, 2026.
         const prevFyEnd = new Date(year, 2, 31);
         // However, don't go back before joining date
         const joining = new Date(prev.profile.joiningDate);
         
         if (prevFyEnd > joining) {
            newProfile.targetDate = prevFyEnd.toISOString().split('T')[0];
         }
      }

      return {
        ...prev,
        profile: newProfile,
        transactions: newTransactions,
        interestRates: newRates
      };
    });
  };

  const handleImport = (newData: AppData) => {
    setData(newData);
  };

  // Recalculate
  const calculations = useMemo(() => calculateTimeline(data), [data]);

  const renderContent = () => {
    switch (currentView) {
      case 'dashboard':
        return (
          <Dashboard 
            data={data} 
            calculations={calculations} 
          />
        );
      case 'years':
        return <YearList years={calculations.years} onDeleteYear={handleDeleteYear} />;
      case 'transactions':
        return (
          <TransactionManager 
            transactions={data.transactions} 
            onAddTransaction={handleAddTransaction}
            onUpdateTransaction={handleUpdateTransaction}
            onDeleteTransaction={handleDeleteTransaction}
          />
        );
      case 'configuration':
        return (
          <Configuration 
            data={data}
            onUpdateProfile={handleUpdateProfile}
            onBatchGenerate={handleBatchGenerate}
            onImport={handleImport}
          />
        );
      default:
        return null;
    }
  };

  if (!isLoaded) return <div className="min-h-screen flex items-center justify-center bg-slate-50 text-slate-400">Loading...</div>;

  return (
    <div className="min-h-screen bg-slate-50 flex flex-col lg:flex-row font-sans text-slate-900">
      <Sidebar 
        currentView={currentView} 
        setView={setCurrentView} 
        isOpen={isSidebarOpen}
        setIsOpen={setIsSidebarOpen}
      />
      
      <main className="flex-1 flex flex-col h-screen overflow-hidden bg-slate-50/50">
        {/* Mobile Header Bar */}
        <div className="lg:hidden bg-[#0f172a] border-b border-slate-800 p-4 flex items-center justify-between shadow-lg z-10">
           <h1 className="font-bold text-white text-lg">EPFO Tracker</h1>
           <button onClick={() => setIsSidebarOpen(true)} className="text-slate-300 hover:text-white">
             <Menu size={24} />
           </button>
        </div>

        <div className="flex-1 overflow-y-auto p-4 lg:p-8">
           <div className="max-w-6xl mx-auto">
             {renderContent()}
           </div>
        </div>
      </main>
    </div>
  );
};

export default App;
